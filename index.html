<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新年烟花</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .start-tip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff0, 0 0 20px #ff0, 0 0 30px #ff0;
            cursor: pointer;
            z-index: 20;
            transition: all 0.5s ease;
        }
        .start-tip.hide {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%) scale(0.8);
        }
        .running-tip {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 5px #ff0;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .running-tip.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="start-tip" id="startTip">请美女点击签收新年夜空</div>
    <div class="running-tip" id="runningTip">新年快乐！点击放烟花呦~</div>
    <canvas id="fireworksCanvas"></canvas>

    <!-- 【必改】替换为你的音效文件名 -->
    <audio id="riseSound" preload="metadata" style="display: none;" volume="0.1">
        <source src="rise.mp3" type="audio/mpeg">
    </audio>
    <audio id="boomSound1" preload="metadata" style="display: none;" volume="1.0">
        <source src="boom1.mp3" type="audio/mpeg">
    </audio>
    <audio id="boomSound2" preload="metadata" style="display: none;" volume="1.0">
        <source src="boom2.mp3" type="audio/mpeg">
    </audio>

    <script>
        // 核心元素与状态（严格流程控制）
        const canvas = document.getElementById('fireworksCanvas');
        const ctx = canvas.getContext('2d');
        const startTip = document.getElementById('startTip');
        const runningTip = document.getElementById('runningTip');
        const riseSound = document.getElementById('riseSound');
        const boomSound1 = document.getElementById('boomSound1');
        const boomSound2 = document.getElementById('boomSound2');
        
        let isStarted = false;
        let isFirstFireworkDone = false;
        let autoTimer = null;
        let riseTrailPoints = [];
        let firstFireworkX = canvas.width / 2; // 首个烟花X：固定底部正中间
        let explodeHeight = canvas.height / 2; // 爆炸高度：屏幕中间

        // 【必改】适配你的rise.mp3准确时长（ms），用音频软件查看
        const RISE_DURATION = 4000;
        // 心形配置：旋转90°后可调整缩放（越大爱心越大）
        const HEART_SCALE = 3;
        // 优化：调大尾迹衰减速度，让粒子消失更快（从0.04→0.08，核心修改1）
        const TRAIL_DECAY = 0.08;

        // 画布适配：强制更新底部中间X和爆炸高度
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            firstFireworkX = canvas.width / 2; // 重算：屏幕水平正中间
            explodeHeight = canvas.height / 2; // 重算：屏幕垂直中间
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 工具函数
        function random(min, max) { return Math.random() * (max - min) + min; }
        function randomColor() {
            const colors = ['#ff0000', '#ff9900', '#ffff00', '#00ff00', '#0099ff', '#0033ff', '#9900ff', '#ff0099'];
            return colors[Math.floor(random(0, colors.length))];
        }

        // 音频逻辑（微信兼容+强制播放）
        function forcePlayAudio(audio) {
            if (!audio) return;
            audio.currentTime = 0;
            audio.play().then(() => {}).catch(() => { audio.load(); audio.play(); });
        }
        function unlockAllAudio() {
            forcePlayAudio(riseSound); setTimeout(() => { riseSound.pause(); riseSound.currentTime = 0; }, 50);
            forcePlayAudio(boomSound1); setTimeout(() => { boomSound1.pause(); boomSound1.currentTime = 0; }, 50);
            forcePlayAudio(boomSound2); setTimeout(() => { boomSound2.pause(); boomSound2.currentTime = 0; }, 50);
        }
        function playRiseSound() {
            forcePlayAudio(riseSound); setTimeout(() => { riseSound.pause(); }, RISE_DURATION);
        }
        function playBoomSound() {
            forcePlayAudio(Math.random() > 0.5 ? boomSound1 : boomSound2);
        }

        // 粒子类
        class Particle {
            constructor(x, y, color, size = 2, decay = random(0.005, 0.01)) {
                this.x = x; this.y = y; this.color = color; this.size = size;
                this.alpha = 1; this.decay = decay; this.vx = 0; this.vy = 0;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.alpha = Math.max(0, this.alpha - this.decay);
            }
            draw() {
                if (this.alpha <= 0) return;
                ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            }
        }
        let particles = [];

        // 上升轨迹：保留原有逻辑，帧级更新+过滤
        function updateRiseTrail(y) {
            riseTrailPoints.push(new Particle(firstFireworkX, y, randomColor(), 1, TRAIL_DECAY));
            riseTrailPoints.forEach(p => p.update());
            riseTrailPoints = riseTrailPoints.filter(p => p.alpha > 0);
            riseTrailPoints.forEach(p => p.draw());
        }

        // 新增：尾迹强制清理函数（核心修改2）
        function clearRiseTrail() {
            // 遍历剩余尾迹，强制将衰减速度拉满，让粒子1-2帧内透明
            riseTrailPoints.forEach(p => p.decay = 1);
            // 立即更新+过滤一次
            riseTrailPoints.forEach(p => p.update());
            riseTrailPoints = riseTrailPoints.filter(p => p.alpha > 0);
        }

        // 核心：90°旋转心形烟花（横向爱心，尖朝右）+ 底部正中间上升
        function createHeartFirework(x, y) {
            const color = randomColor();
            const particleCount = 500; // 心形粒子数，保证形状清晰
            for (let i = 0; i < particleCount; i++) {
                const p = new Particle(x, y, color, 2.5);
                const theta = random(0, 2 * Math.PI);
                const r = 16 * Math.pow(Math.sin(theta), 3);
                const dx_org = 13 * Math.cos(theta) - 5 * Math.cos(2 * theta) - 2 * Math.cos(3 * theta) - Math.cos(4 * theta);
                const dx = -r * HEART_SCALE / 10;
                const dy = -dx_org * HEART_SCALE / 10;
                p.vx = dx;
                p.vy = dy + random(0.1, 0.3);
                particles.push(p);
            }
            // 关键修改：在创建心形烟花粒子的同时播放爆炸音效
            playBoomSound();
        }

        // 首个烟花：上升结束后立即调用尾迹清理（核心修改3）
        function startFirstHeartFirework() {
            let currentY = canvas.height;
            const riseSpeed = (canvas.height - explodeHeight) / RISE_DURATION;
            playRiseSound();

            const riseInterval = setInterval(() => {
                currentY -= riseSpeed * 16;
                updateRiseTrail(currentY);
                if (currentY <= explodeHeight) {
                    clearInterval(riseInterval);
                    // 上升停止：立即清理一次尾迹
                    clearRiseTrail();
                    createHeartFirework(firstFireworkX, explodeHeight);
                    // 移除原有的playBoomSound()调用，统一移到createHeartFirework函数内
                    // 心形爆炸消失后，再强制清理一次尾迹（双重保障）
                    setTimeout(() => {
                        clearRiseTrail();
                        isFirstFireworkDone = true;
                        startAutoFirework();
                        runningTip.classList.add('show');
                    }, 1000);
                }
            }, 16);
        }

        // 普通烟花（自动/点击）
        function createNormalFirework(x, y) {
            const color = randomColor();
            for (let i = 0; i < random(100, 150); i++) {
                const p = new Particle(x, y, color);
                p.vx = random(-5, 5); p.vy = random(-5, 5) + random(0.2, 0.5);
                particles.push(p);
            }
        }
        // 自动烟花
        function createAutoFireworkBatch() {
            if (!isFirstFireworkDone) return;
            const count = Math.floor(random(4, 10));
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const x = random(canvas.width * 0.1, canvas.width * 0.9);
                    const y = random(canvas.height * 0.2, canvas.height * 0.7);
                    createNormalFirework(x, y);
                    playBoomSound();
                }, random(50, 200) * i);
            }
        }
        function startAutoFirework() {
            createAutoFireworkBatch();
            autoTimer = setInterval(createAutoFireworkBatch, random(2000, 4000));
        }
        // 点击放烟花：仅首个烟花完成后响应
        function clickToFirework(x, y) {
            if (!isStarted || !isFirstFireworkDone) return;
            createNormalFirework(x, y);
            playBoomSound();
        }

        // 动画主循环：帧级更新，确保无残留
        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            riseTrailPoints.forEach(p => p.draw());
            particles.forEach((p, i) => { p.update(); p.draw(); if (p.alpha <= 0) particles.splice(i, 1); });
            requestAnimationFrame(animate);
        }
        animate();

        // 初始点击开始
        function startAll() {
            if (isStarted) return;
            isStarted = true;
            startTip.classList.add('hide');
            unlockAllAudio();
            setTimeout(startFirstHeartFirework, 100);
        }

        // 事件绑定（PC+移动端）
        startTip.addEventListener('click', startAll);
        canvas.addEventListener('click', (e) => { !isStarted ? startAll() : clickToFirework(e.clientX, e.clientY); });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            !isStarted ? startAll() : clickToFirework(touch.clientX, touch.clientY);
        }, { passive: false });
    </script>
</body>
</html>