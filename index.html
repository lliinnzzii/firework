<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新年烟花送祝福</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #000; /* 强制初始黑色背景，避免黑屏 */
        }
        .start-tip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff0, 0 0 20px #ff0, 0 0 30px #ff0;
            cursor: pointer;
            z-index: 20;
            transition: all 0.5s ease;
        }
        .start-tip.hide {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%) scale(0.8);
        }
        .running-tip {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 5px #ff0;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .running-tip.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="start-tip" id="startTip">点击签收</div>
    <div class="running-tip" id="runningTip">点击可以放烟花呦~</div>
    <canvas id="fireworksCanvas"></canvas>

    <!-- 闭合audio标签，避免HTML解析错误 -->
    <audio id="riseSound" preload="none" style="display: none;" volume="0.05">
        <source src="rise.mp3" type="audio/mpeg">
    </audio>
    <audio id="boomSound1" preload="none" style="display: none;" volume="1.0">
        <source src="boom1.mp3" type="audio/mpeg">
    </audio>
    <audio id="boomSound2" preload="none" style="display: none;" volume="1.0">
        <source src="boom2.mp3" type="audio/mpeg">
    </audio>

    <script>
        // 确保DOM加载完成后执行脚本
        document.addEventListener('DOMContentLoaded', function() {
            // 核心元素与状态
            const canvas = document.getElementById('fireworksCanvas');
            const ctx = canvas.getContext('2d');
            const startTip = document.getElementById('startTip');
            const runningTip = document.getElementById('runningTip');
            const riseSound = document.getElementById('riseSound');
            const boomSound1 = document.getElementById('boomSound1');
            const boomSound2 = document.getElementById('boomSound2');
            
            // 防错：确保画布上下文获取成功
            if (!ctx) {
                alert('您的浏览器不支持Canvas，无法显示烟花效果');
                return;
            }

            let isStarted = false;
            let isFirstFireworkDone = false;
            let autoTimer = null;
            let riseTrailPoints = [];
            let riseInterval = null; // 新增：保存上升定时器，用于彻底清除
            let firstFireworkX = canvas.width / 2;
            let explodeHeight = canvas.height / 2;
            // 祝福语数组
            const wishList = [
                "新年快乐", "万事顺意", "朝朝暮暮", "一生被爱", "平安喜乐",
                "前程似锦", "笑口常开", "心想事成", "喜乐无忧", "与你同喜",
                "小薄同学", "小薄同学", "小薄同学", "小薄同学", "小薄同学"
            ];
            let wishTexts = []; // 存储文字对象

            // 配置参数（【关键修改】加快衰减，缩短存在时间）
            const RISE_DURATION = 3000; // 缩短上升时间，提升流畅度
            const HEART_SCALE = 3.5;
            const TRAIL_DECAY = 0.12; // 【修改1】轨迹粒子衰减翻倍，更快消失
            const TEXT_DECAY = 0.015; // 【修改2】文字衰减翻倍+，更快消失
            let particles = [];

            // 画布适配
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                firstFireworkX = canvas.width / 2;
                explodeHeight = canvas.height / 2;
                // 重绘黑色背景
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // 工具函数
            function random(min, max) { return Math.random() * (max - min) + min; }
            // 生成同色系颜色（心形烟花）
            function getHeartColorSet() {
                const baseHue = random(0, 360);
                return {
                    main: `hsl(${baseHue}, 100%, 60%)`,
                    light: `hsl(${baseHue}, 100%, 75%)`,
                    dark: `hsl(${baseHue}, 100%, 45%)`
                };
            }
            // 随机获取祝福语
            function getRandomWish() {
                return wishList[Math.floor(random(0, wishList.length))];
            }
            // 适配文字大小
            function getAdaptedTextSize() {
                const minSize = Math.min(canvas.width, canvas.height) * 0.02;
                const maxSize = Math.min(canvas.width, canvas.height) * 0.035;
                return random(minSize, maxSize);
            }
            // 随机颜色（普通烟花）
            function randomColor() {
                const colors = ['#ff0000', '#ff9900', '#ffff00', '#00ff00', '#0099ff', '#0033ff', '#9900ff', '#ff0099'];
                return colors[Math.floor(random(0, colors.length))];
            }

            // 音频逻辑（增加容错，无音频不报错）
            function forcePlayAudio(audio) {
                if (!audio) return;
                try {
                    audio.currentTime = 0;
                    audio.play().catch(() => {}); // 捕获错误，不阻塞动画
                } catch (e) {}
            }
            function unlockAllAudio() {
                forcePlayAudio(riseSound);
                setTimeout(() => { riseSound.pause(); riseSound.currentTime = 0; }, 50);
                forcePlayAudio(boomSound1);
                setTimeout(() => { boomSound1.pause(); boomSound1.currentTime = 0; }, 50);
                forcePlayAudio(boomSound2);
                setTimeout(() => { boomSound2.pause(); boomSound2.currentTime = 0; }, 50);
            }
            function playRiseSound() { forcePlayAudio(riseSound); setTimeout(() => { riseSound.pause(); }, RISE_DURATION); }
            function playBoomSound() { forcePlayAudio(Math.random() > 0.5 ? boomSound1 : boomSound2); }

            // 粒子类（【修改3】增大粒子基础衰减，加快消失）
            class Particle {
                constructor(x, y, color, size = 2, decay = random(0.01, 0.015), isHighlight = false) {
                    this.x = x; 
                    this.y = y; 
                    this.color = color; 
                    this.size = size;
                    this.alpha = 1; 
                    this.decay = decay; // 基础衰减从 0.004-0.008 提升到 0.01-0.015
                    this.vx = 0; 
                    this.vy = 0;
                    this.isHighlight = isHighlight;
                    this.flashSpeed = isHighlight ? random(0.02, 0.04) : 0;
                }
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    if (this.isHighlight) {
                        this.alpha = Math.max(0, this.alpha - this.decay + Math.sin(Date.now() * 0.005) * this.flashSpeed);
                    } else {
                        this.alpha = Math.max(0, this.alpha - this.decay);
                    }
                    this.vy += 0.03; // 【修改4】重力从 0.018 提升到 0.03，粒子更快下落消失
                }
                draw() {
                    if (this.alpha <= 0) return;
                    ctx.save(); 
                    ctx.globalAlpha = this.alpha; 
                    ctx.fillStyle = this.color;
                    if (this.isHighlight) {
                        ctx.shadowBlur = 2;
                        ctx.shadowColor = this.color;
                    }
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
                    ctx.fill(); 
                    ctx.restore();
                }
            }

            // 重构：接收指定的祝福语文本，不再随机生成
            function createWishText(x, y, color, text) {
                wishTexts.push({
                    x: x,
                    y: y,
                    text: text, // 使用传入的指定文本
                    alpha: 1,
                    color: color,
                    size: getAdaptedTextSize()
                });
            }
            function drawWishText(textObj) {
                if (textObj.alpha <= 0) return;
                ctx.save();
                ctx.globalAlpha = textObj.alpha;
                ctx.font = `bold ${textObj.size}px PingFang SC, Microsoft YaHei, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = textObj.color;
                ctx.shadowBlur = 6;
                ctx.shadowColor = textObj.color;
                ctx.fillText(textObj.text, textObj.x, textObj.y);
                ctx.restore();
            }
            function updateWishTexts() {
                wishTexts.forEach((text, i) => {
                    text.alpha = Math.max(0, text.alpha - TEXT_DECAY);
                    drawWishText(text);
                    if (text.alpha <= 0) wishTexts.splice(i, 1);
                });
            }

            // 上升轨迹 - 优化：彻底清除无残留
            function updateRiseTrail(y) {
                riseTrailPoints.push(new Particle(firstFireworkX, y, randomColor(), 1, TRAIL_DECAY));
                riseTrailPoints.forEach(p => p.update());
                riseTrailPoints = riseTrailPoints.filter(p => p.alpha > 0);
                riseTrailPoints.forEach(p => p.draw());
            }
            // 重写：彻底清空轨迹粒子，替代原衰减方式，解决尾迹残留
            function clearRiseTrail() {
                riseTrailPoints = []; // 直接清空数组，无任何残留
                if (riseInterval) {
                    clearInterval(riseInterval); // 清除定时器，停止生成新轨迹
                    riseInterval = null;
                }
            }

            // 重构心形烟花：减少粒子数，配合快衰减更协调
            function createHeartFirework(x, y, wishText) {
                const colorSet = getHeartColorSet();
                const totalParticles = 400; // 粒子数从 500 减少到 400
                // 核心粒子
                for (let i = 0; i < totalParticles * 0.7; i++) {
                    const p = new Particle(x, y, colorSet.main, 2.5, 0.012, false);
                    const theta = random(0, 2 * Math.PI);
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    const rx = 16 * Math.pow(sinTheta, 3);
                    const ry = 13 * cosTheta - 5 * Math.cos(2 * theta) - 2 * Math.cos(3 * theta) - Math.cos(4 * theta);
                    p.vx = (rx * HEART_SCALE / 8) * random(0.85, 1.05);
                    p.vy = (-ry * HEART_SCALE / 8) * random(0.85, 1.05) + 0.1;
                    particles.push(p);
                }
                // 高光粒子
                for (let i = 0; i < totalParticles * 0.2; i++) {
                    const p = new Particle(x, y, colorSet.light, 1.5, 0.014, true);
                    const theta = random(0, 2 * Math.PI);
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    const rx = 16 * Math.pow(sinTheta, 3);
                    const ry = 13 * cosTheta - 5 * Math.cos(2 * theta) - 2 * Math.cos(3 * theta) - Math.cos(4 * theta);
                    p.vx = (rx * HEART_SCALE / 8) * random(1.0, 1.1);
                    p.vy = (-ry * HEART_SCALE / 8) * random(1.0, 1.1) + 0.1;
                    particles.push(p);
                }
                // 点缀粒子
                for (let i = 0; i < totalParticles * 0.1; i++) {
                    const p = new Particle(x, y, colorSet.dark, 2.8, 0.01, false);
                    const theta = random(0, 2 * Math.PI);
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    const rx = 16 * Math.pow(sinTheta, 3);
                    const ry = 13 * cosTheta - 5 * Math.cos(2 * theta) - 2 * Math.cos(3 * theta) - Math.cos(4 * theta);
                    p.vx = (rx * HEART_SCALE / 8) * random(0.8, 0.9);
                    p.vy = (-ry * HEART_SCALE / 8) * random(0.8, 0.9) + 0.1;
                    particles.push(p);
                }
                // 显示指定的祝福语
                createWishText(x, y, colorSet.light, wishText);
                playBoomSound();
            }

            // 重构普通烟花：减少粒子数，配合快衰减更协调
            function createNormalFirework(x, y, wishText) {
                const color = randomColor();
                for (let i = 0; i < random(60, 90); i++) { // 粒子数从 80-120 减少到 60-90
                    const p = new Particle(x, y, color);
                    p.vx = random(-4, 4); 
                    p.vy = random(-4, 4) + random(0.1, 0.4);
                    particles.push(p);
                }
                // 显示指定的祝福语
                createWishText(x, y, color, wishText);
                playBoomSound();
            }

            // 新增：统一的烟花生成逻辑（判断祝福类型，选择烟花样式）
            function createFireworkByWish(x, y) {
                // 先随机获取祝福语
                const wishText = getRandomWish();
                // 判断是否是“小薄同学”，是则生成心形，否则生成普通
                if (wishText === "小薄同学") {
                    createHeartFirework(x, y, wishText);
                } else {
                    createNormalFirework(x, y, wishText);
                }
            }

            // 改造自动燃放烟花：使用统一的生成逻辑
            function createAutoFireworkBatch() {
                if (!isFirstFireworkDone) return;
                const count = Math.floor(random(3, 5));
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const x = random(canvas.width * 0.1, canvas.width * 0.9);
                        const y = random(canvas.height * 0.2, canvas.height * 0.7);
                        // 调用统一逻辑生成烟花
                        createFireworkByWish(x, y);
                    }, random(50, 200) * i);
                }
            }
            function startAutoFirework() {
                createAutoFireworkBatch();
                autoTimer = setInterval(createAutoFireworkBatch, random(2000, 3500));
            }

            // 首个爱心烟花 - 修复：绑定定时器到全局变量
            function startFirstHeartFirework() {
                let currentY = canvas.height;
                const riseSpeed = (canvas.height - explodeHeight) / RISE_DURATION;
                playRiseSound();

                // 把定时器赋值给全局变量，方便后续清除
                riseInterval = setInterval(() => {
                    currentY -= riseSpeed * 16;
                    updateRiseTrail(currentY);
                    if (currentY <= explodeHeight) {
                        clearRiseTrail(); // 立即彻底清除轨迹，无残留
                        // 首个烟花固定用心形，随机选一个祝福
                        createHeartFirework(firstFireworkX, explodeHeight, getRandomWish());
                        setTimeout(() => {
                            isFirstFireworkDone = true;
                            startAutoFirework();
                            runningTip.classList.add('show');
                        }, 800);
                    }
                }, 16);
            }

            // 改造点击放烟花：使用统一的生成逻辑
            function clickToFirework(x, y) {
                if (!isStarted || !isFirstFireworkDone) return;
                createFireworkByWish(x, y);
            }

            // 动画主循环 - 【修改5】提高背景覆盖透明度，残影更快消失
            function animate() {
                // 半透明覆盖，实现残影（透明度从 0.12 提升到 0.2，更快覆盖）
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // 仅当轨迹数组有内容时才绘制，避免空绘制残留
                if (riseTrailPoints.length > 0) {
                    riseTrailPoints.forEach(p => p.draw());
                }
                // 绘制粒子
                particles.forEach((p, i) => { 
                    p.update(); 
                    p.draw(); 
                    if (p.alpha <= 0) particles.splice(i, 1); 
                });
                // 绘制祝福语
                updateWishTexts();
                // 循环动画
                requestAnimationFrame(animate);
            }
            // 启动动画循环
            animate();

            // 开始所有效果
            function startAll() {
                if (isStarted) return;
                isStarted = true;
                startTip.classList.add('hide');
                unlockAllAudio();
                setTimeout(startFirstHeartFirework, 300);
            }

            // 事件绑定
            startTip.addEventListener('click', startAll);
            // 画布点击
            canvas.addEventListener('click', (e) => { 
                !isStarted ? startAll() : clickToFirework(e.clientX, e.clientY); 
            });
            // 移动端触摸
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                !isStarted ? startAll() : clickToFirework(touch.clientX, touch.clientY);
            }, { passive: false });
        });
    </script>
</body>
</html>